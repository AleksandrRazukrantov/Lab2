## Отчет по лабораторной работе № 2

#### № группы: `ПМ-2501`

#### Выполнил: `Разукрантов Александр Евгеньевич`

#### Вариант: `18`

### Cодержание:

- [Задание 1](#1-Задание-1)
- [Задание 2](#2-Задание-2)
- [Задание 3](#3-Задание-3)
- [Задание 4](#4-Задание-4)

### 1. Задание 1
- [Постановка задачи 1](#a-постановка-задачи-1)
- [Входные и выходные данные 1](#b-входные-и-выходные-данные-1)
- [Алгоритм 1](#c-алгоритм-1)
- [Программа 1](#d-программа-1)
- [Анализ правильности решения 1](#e-анализ-правильности-решения-1)
### a) Постановка задачи 1

> Программа получает на вход 2 числа a0 (нулевой элемент последовательности, при этом он сам не является частью последовательности)  и n (количество элементов последовательности). Нужно, из условия, определить принцип последовательности и вывести последовательность, состоящую из n элементов, где нулевым членом будет а0. 

### b) Входные и выходные данные 1

#### Данные на вход

Программа получает на вход 2 числа a0(целое неотрицательное)  и n(натуральное).

#### Данные на выход

На выход мы получим n чисел - последовательность

### c) Алгоритм 1

#### Алгоритм выполнения программы:

1. **Ввод данных:**  
   Программа считывает два числа, обозначенные как `а0` и `n`.

2. **Принцып последовательности:**  
   Из условия можно понять: элемент последовательности равен предедущему элементу последовательности (изначально равному а0) умноженему на два, если он становиться больше 18, то вычитаеться 18.
3. **Сосдание последовательности:**
    Используем цикл for (пробегаем от 0 до n (не включительно), таким образом получим нужную длину последовательности): в теле цикла переприсваиваем значение а0 на а0*2, далее проверяем если а0 > 18, то вычетаем из а0 18. Выводим а0 на экран.

### d) Программа 1

```
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);

    public static void main(String[] args) {

            int a0 = in.nextInt();
            int n = in.nextInt();

            for(int i = 0; i < n; i++) {
                a0 *= 2;
                if (a0 > 18){
                    a0 -= 18;
                }
                System.out.print(a0 + " ");
            }
      }
}
```

### e) Анализ правильности решения 1

Программа работает корректно на всем множестве решений с учетом ограничений.

1. Тест на a0 = 1, n = 10:

    - **Input**:
        ```
        1
        10
        ```

    - **Output**:
        ```
        2 4 8 16 14 10 2 4 8 16 
        ```
2. Тест на a0 = 0, n = 10:

    - **Input**:
        ```
        0
        10
        ```

    - **Output**:
        ```
        0 0 0 0 0 0 0 0 0 0 
        ```
3. Тест на a0 = 9, n = 5:

    - **Input**:
        ```
        9
        5
        ```

    - **Output**:
        ```
        18 18 18 18 18 
        ```
### 2. Задание 2
- [Постановка задачи 2](#a-постановка-задачи-2)
- [Входные и выходные данные 2](#b-входные-и-выходные-данные-2)
- [Алгоритм 2](#c-алгоритм-2)
- [Программа 2](#d-программа-2)
- [Анализ правильности решения 2](#e-анализ-правильности-решения-2)
### a) Постановка задачи 2

> С клавиатуры вводится натуральное число N (N < 20). Вывести на экран десятичное представление числа, которое в троичном виде состоит из N единиц.

### b) Входные и выходные данные 2

#### Данные на вход

Натуральное число N (N < 20).

#### Данные на выход

Натурально число (десятичное представление числа, которое в троичном виде состоит из N единиц).

### c) Алгоритм 2

#### Алгоритм выполнения программы:

1. **Ввод данных:**  
   Программа считывает натуральное число, обозначенное как `N`.

2. **Алгоритм:**  
  Создаем переменную s (изначальное значение 0), используем цикл for (пробегаем от 0 до N): в теле цикла меняем значение s на s*3 + 1.
3. **Вывод результата:**  
    Выводим s.
### d) Программа 2

```
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);

    public static void main(String[] args) {

        int N = in.nextInt();
        int s = 0;
        for(int i = 0; i < N; i++){
            s = s*3 + 1;
        }
        System.out.println(s);
    }
}

```

### e) Анализ правильности решения 2

Программа работает корректно на всем множестве решений с учетом ограничений.

1. Тест на N = 2:

    - **Input**:
        ```
        2
        ```

    - **Output**:
        ```
        4
        ```
2. Тест на N = 10:

    - **Input**:
        ```
        10
        ```

    - **Output**:
        ```
        29524
        ```
### 3. Задание 3
- [Постановка задачи 3](#a-постановка-задачи-3)
- [Входные и выходные данные 3](#b-входные-и-выходные-данные-3)
- [Алгоритм 3](#c-алгоритм-3)
- [Программа 3](#d-программа-3)
- [Анализ правильности решения 3](#e-анализ-правильности-решения-3)
### a) Постановка задачи 3

> Программа получает на вход 4 числа Р0, g, m и Cap. Нужно определить, через сколько лет население микрарайона (Р0) превысит Сар(каждый год Р0 увеличиваеться на (P0 * g / 100) + m)

### b) Входные и выходные данные 3

#### Данные на вход

Р0, g(от 0 до 100) и Cap - натуральные числа, m - целое(так как миграция может быть отрицаткльной)

#### Данные на выход

Натуральное число n - сколько лет население микрарайона (Р0) превысит Сар или уведомление, что население микрарайона постоянно уменьшаеться.

### c) Алгоритм 3

#### Алгоритм выполнения программы:

1. **Ввод данных:**  
   Программа считывает четыре натуральных числа, обозначенные как `P0`,`g`,`m` и `Cap`.

2. **Поиск:**  
   Сначала, проверяем уменьшается прирост населения или нет, для того чтобы прирост населения уменьшался нужно: ((P0 * g / 100) + m) < 0, если верно, выводим "Население микрарайона постоянно уменьшается", иначе создаем переменную n, для подсчета лет, используем цикл while(пока Р0 < Сар): в теле цикла меняем значение Р0 на (Р0 + (P0 * g / 100) + m) и прибавляем 1 к n.

3. **Вывод результата:**  
   На экран выводится:
   1. Либо n - сколько лет насиление микрарайона (Р0) превысит Сар.
   2. Уведомление: "Население микрарайона постоянно уменьшается".


### d) Программа 3

```
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);

    public static void main(String[] args) {

       int P0 = in.nextInt();
        double g = in.nextDouble();
        int m = in.nextInt();
        int Cap = in.nextInt();
        int n = 0;

        if(((int)(P0 * g / 100)) + m < 0){
            System.out.println("Население микрарайона постоянно уменьшается");
        }
        else{
            while (P0 < Cap){
                P0 = P0 + ((int)(P0 * g / 100)) + m;
                n++;
            }
            System.out.println(n);
        }
    }
}
```

### e) Анализ правильности решения 3

Программа работает корректно на всем множестве решений с учетом ограничений.

1. Тест на Р0 = 100, g = 100, m = 0, Cap = 1000:

    - **Input**:
        ```
        100
        100
        0
        1000
        ```

    - **Output**:
        ```
        4
        ```
2. Тест на Р0 = 100, g = 10, m = -90, Cap = 1000:

    - **Input**:
        ```
        100
        10
        -90
        1000
        ```

    - **Output**:
        ```
        Население микрарайона постоянно уменьшаеться
        ```
### 4. Задание 4
- [Постановка задачи 4](#a-постановка-задачи-4)
- [Входные и выходные данные 4](#b-входные-и-выходные-данные-4)
- [Алгоритм 4](#c-алгоритм-4)
- [Программа 4](#d-программа-4)
- [Анализ правильности решения 4](#e-анализ-правильности-решения-4)
### a) Постановка задачи 4

> Дана последовательность из n элементов. Определить, есть ли такие элементы, которые встречаются в последовательности ровно столько раз, каково их значение.
### b) Входные и выходные данные 4

#### Данные на вход
Натуральне число n(количество элементов) и последовательность n чисел (элемент принемает значение от 10 до 100 включительно).
#### Данные на выход

Числа удовлетворяющие условию(число встречается в последовательности ровно столько раз, каково его значение) или NO.

### c) Алгоритм 4

#### Алгоритм выполнения программы:

1. **Ввод данных:**  
   Программа считывает натуральное число n и n чисел.

2. **Поиск чисел:**  
   Создаем массив b длинной 101(101 так как все элементы от 10 до 100) и boolean переменную f с начальным значением true(флажок), используем цикл for: в теле цикла вводим с клавиатуры а - элемент последовательности, и увеличиваем на 1 значение элемнта в массиве b c индексом а - элемента последовательности(b[a]). Таким образом в массиве b будет сколько число от 10 до 100 (включительно) встречалось в последовательности. Используем for(пробегаем по массиву b): в теле цикла, если элемент b равен индексу, то вывести этот элемент и поменять значение f на false. После окончания цикла проверяем, если f равно true, то выводим "NO".
3. **Вывод результата:**  
   На экран выводится:
   1. Либо числа удовлетворяющие условию( число встречается в последовательности ровно столько раз, каково его значение)
   2. Или NO
 
### d) Программа 4

```
import java.util.Scanner;
public class Main {
    public static Scanner in = new Scanner(System.in);

    public static void main(String[] args) {

       int n = in.nextInt();
        int a;
        boolean f = true;
        int[] b = new int[101];

        for(int i = 0; i < n; i++){
            a = in.nextInt();
            b[a]++;
        }
        for(int i = 10; i < 101; i++){
            if (b[i] == i){
                System.out.print(b[i] + " ");
                f = false;
            }
        }

        if (f){
            System.out.println("NO");
        }

    }
}

```

### e) Анализ правильности решения 4

Программа работает корректно на всем множестве решений с учетом ограничений.

1. Тест на n = 11:

    - **Input**:
        ```
        11
        11 11 11 11 11 11 11 11 11 11 11
        ```

    - **Output**:
        ```
        11
        ```
2. Тест на n = 10:

    - **Input**:
        ```
        10
        11 11 11 11 11 11 11 11 11 11
        ```

    - **Output**:
        ```
        NO
        ```

